# Zuspec Dataclasses Library

## Overview

Zuspec is a Python-embedded multi-abstraction language for modeling hardware designs from transfer-function level down to register transfer level (RTL). The library provides decorators and types to capture hardware model semantics at various abstraction levels.

## Installation

```bash
pip install zuspec-dataclasses
```

For development, fetch dependencies using IVPM:
```bash
uvx ivpm update
```

## Core Concepts

### 1. Components

Components are structural elements equivalent to Verilog modules or SystemC components. They provide the architectural framework for hardware models.

```python
import zuspec.dataclasses as zdc

@zdc.dataclass
class Counter(zdc.Component):
    clock : zdc.Bit = zdc.input()
    reset : zdc.Bit = zdc.input()
    count : zdc.Bit[32] = zdc.output()
    
    @zdc.sync(clock=lambda s:s.clock, reset=lambda s:s.reset)
    def _inc(self):
        if self.reset:
            self.count = 0
        else:
            self.count += 1
```

**Key Features:**
- Use `@zdc.dataclass` decorator on classes extending `zdc.Component`
- Define ports using `zdc.input()`, `zdc.output()`, or `zdc.port()`
- Implement behavior using exec methods: `@sync`, `@comb`, or `@process`

### 2. Data Types

#### Integer Types

- **Bit**: Unsigned integer type, default width 1
- **Int**: Signed integer type, default width 32

```python
@zdc.dataclass
class MyComponent(zdc.Component):
    int_64b : zdc.Int = zdc.field(width=64)
    bit_48b : zdc.Bit = zdc.field(width=48)
    bit_16b : zdc.Bit[16] = zdc.output()  # Using subscript notation
```

#### Python Types
Standard Python types (int, str, list, dict, set, tuple) are also supported for behavioral modeling.

### 3. Struct Types

Structs are data containers, available in two flavors:

```python
@zdc.dataclass
class MyStruct(zdc.Struct):
    W : int = zdc.const(default=10)
    a : int = zdc.field(rand=True, domain=range(10))
    b : int = zdc.rand()
```

**Built-in Methods:**
- `bind()`: Returns dependency bind mappings
- `pre_randomize()`, `post_randomize()`, `randomize()`: Constraint solving hooks

### 4. Actions

Actions are dynamic behavioral elements typically used for test modeling. They are associated with a component context.

```python
class MyC(zdc.Component):
    a : int = 5

class MyA(zdc.Action[MyC]):
    def post_solve(self):
        print("comp.a=%d" % self.comp.a)
```

**Built-in Methods:**
- `activity()`: Async method providing action implementation
- `body()`: Alternative async method for implementation

### 5. Exec Methods

Exec methods define behavioral semantics and are evaluated automatically based on events.

#### @sync - Synchronous Logic
Evaluated on clock or reset edge transitions. All output assignments are non-blocking.

```python
@zdc.sync(clock=lambda s:s.clock, reset=lambda s:s.reset)
def inc(self):
    if self.reset:
        self.count = 0
    else:
        self.count += 1
```

#### @comb - Combinational Logic
Evaluated whenever referenced variables change. Used exclusively for RTL descriptions.

#### @process - Concurrent Process
Async method evaluated when component evaluation begins. Creates an independent thread of control.

```python
@zdc.process
async def run(self):
    for i in range(20):
        await self.dat_o(i)
```

### 6. Field Specifications

Fields follow Python dataclasses pattern with additional hardware semantics:

```python
@zdc.dataclass
class Example(zdc.Struct):
    W : int = zdc.const(default=10)        # Post-init constant
    a : int = zdc.field(rand=True)          # Random field
    b : int = zdc.rand()                    # Random field (convenience)
    inp : zdc.Bit = zdc.input()            # Input port
    outp : zdc.Bit[8] = zdc.output()       # Output port
```

**Field Options:**
- `default`: Reset/initial value
- `rand`: Marks field as randomizable
- `const`: Marks field as constant after initialization
- `domain`: Iterable or callable defining field value domain
- `bind`: Dependency binding specification
- `width`: For Bit/Int types, specifies bit width

**Convenience Functions:**
- `zdc.input()`: Define input port
- `zdc.output()`: Define output port
- `zdc.port()`: Define bidirectional port
- `zdc.export()`: Make container a dependency provider
- `zdc.const()`: Define constant field
- `zdc.rand()`: Define random field

### 7. Constraints

Constraints relate random variables using declarative boolean statements.

```python
@zdc.dataclass
class MyS(zdc.Struct):
    a : int = zdc.field(rand=True)
    b : int = zdc.field(rand=True)
    c : int = zdc.field(rand=True)
    
    @zdc.constraint
    def ab_c(self):
        self.a > 0 and self.a < 10
        self.b in range(0, 9)
        self.a < self.b
```

**Constraint Functions:**
Reusable constraints that apply when referenced:

```python
@zdc.constraint
def max(rv, v1, v2):
    rv == v1 if v1 > v2 else v2

@zdc.constraint(fn=True)
def a_range_small(self):
    self.a in range(0, 9)
```

**Supported Operators:**
- Boolean expressions with `and`, `or`, `not`
- `in` operator with range(), generators, lists, tuples
- Comparison operators: `<`, `>`, `<=`, `>=`, `==`, `!=`
- Conditional: `if/else`

### 8. TLM (Transaction Level Modeling)

Support for producer-consumer patterns and port binding:

```python
from typing import Awaitable, Callable, Self

@zdc.dataclass
class Producer(zdc.Component):
    dat_o : Callable[[int],Awaitable] = zdc.port()
    dat_i : Callable[[int],Awaitable] = zdc.export(bind=zdc.bind[Self](lambda s:s.recv))
    
    async def recv(self, dat):
        # Handle received data
        pass

@zdc.dataclass
class Top(zdc.Component):
    p : Producer = zdc.field(bind=zdc.bind[Self](lambda s: {
        s.p.dat_i : s.c.dat_o
    }))
    c : Consumer = zdc.field(bind=zdc.bind[Self](lambda s: {
        s.c.dat_i : s.p.dat_o
    }))
```

### 9. API for Tool Integration

The `zuspec.dataclasses.api` package provides visitor patterns for tools to operate on Zuspec models:

```python
import zuspec.dataclasses.api as api

class MyVisitor(api.Visitor):
    def visitComponentType(self, t):
        # Process component type
        pass
    
    def visitInput(self, field):
        # Process input port
        pass
    
    def visitOutput(self, field):
        # Process output port
        pass

visitor = MyVisitor()
visitor.visit(MyComponent)
```

### 10. Profiles

Profiles specify capability sets and restrictions for different modeling levels:
- Synthesizable RTL
- Behavioral RTL
- Behavioral HVL (Hardware Verification Language)
- Portable TLM
- Portable Test

## Common Patterns

### Counter with Reset
```python
@zdc.dataclass
class Counter(zdc.Component):
    clock : zdc.Bit = zdc.input()
    reset : zdc.Bit = zdc.input()
    count : zdc.Bit[16] = zdc.output()
    
    @zdc.sync(clock=lambda s:s.clock, reset=lambda s:s.reset)
    def _inc(self):
        if self.reset:
            self.count = 0
        else:
            self.count += 3
```

### Producer-Consumer Communication
```python
@zdc.dataclass
class Producer(zdc.Component):
    dat_o : Callable[[int],Awaitable] = zdc.port()
    
    @zdc.process
    async def run(self):
        for i in range(20):
            await self.dat_o(i)

@zdc.dataclass
class Consumer(zdc.Component):
    dat_i : Callable[[int],Awaitable] = zdc.export(bind=zdc.bind[Self](lambda s:s.recv))
    
    async def recv(self, dat):
        # Process received data
        pass
```

### Randomizable Data Structure
```python
@zdc.dataclass
class Transaction(zdc.Struct):
    addr : int = zdc.field(rand=True)
    data : int = zdc.field(rand=True)
    
    @zdc.constraint
    def addr_range(self):
        self.addr in range(0x1000, 0x2000)
        self.data > 0
```

## Best Practices

1. **Always use `@zdc.dataclass` decorator** on Zuspec classes
2. **Use type annotations** for all fields to enable proper type checking
3. **Use lambda expressions for clock/reset** in `@sync` decorators
4. **Keep constraints declarative** - avoid procedural logic in constraint blocks
5. **Use appropriate exec method** - `@sync` for RTL, `@process` for behavioral
6. **Leverage field convenience functions** - `input()`, `output()`, `port()`, etc.
7. **Use `Self` type hint** for self-referential bindings in field specifications

## Dependencies

The library depends on standard Python packages and follows the dataclasses pattern. Use IVPM for managing Zuspec-specific dependencies during development.

## License

Licensed under Apache License 2.0. Copyright 2019-2025 Matthew Ballance and contributors.

## Additional Resources

- Documentation: See `docs/` directory for detailed Sphinx documentation
- Examples: See `tests/unit/` directory for usage examples
- API: Import `zuspec.dataclasses.api` for tool integration capabilities
