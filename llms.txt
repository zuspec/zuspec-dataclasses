# Zuspec Language - LLM Reference Guide

## Overview

Zuspec is a Python-embedded multi-abstraction language for modeling digital hardware designs from abstract behavioral models down to register transfer level (RTL). It follows Python dataclasses patterns while applying special semantic rules to hardware descriptions.

## Core Concepts

### Import Statement
```python
import zuspec.dataclasses as zdc
```

### Decorators and Core Classes

#### @zdc.dataclass
Marks a class as a Zuspec type. Use this decorator on all Zuspec classes (Component, Struct, Action, etc.).

#### Base Type Classes
- **zdc.Component**: Structural elements equivalent to Verilog modules or SystemC components
- **zdc.Struct**: Data structures that may contain variable-size fields
- **zdc.StructPacked**: Fixed-size data structures with support for bit fields
- **zdc.Action[CompT]**: Dynamic behavioral elements, typically for test behavior
- **zdc.Bundle**: Collections of ports, exports, inputs, outputs, or bundles

## Data Types

### Numeric Types
- **zdc.Bit**: Unsigned bit type with default width of 1. Use `zdc.Bit[N]` for N-bit width.
- **zdc.Int**: Signed integer type with default width of 32. Use `zdc.Int[N]` for N-bit width.

Example:
```python
@zdc.dataclass
class MyC(zdc.Component):
    count : zdc.Bit[16] = zdc.output()
    value : zdc.Int[32] = zdc.field()
```

### Field Declarations

#### zdc.field()
General purpose field declaration with options:
- `rand=True`: Marks field as randomizable
- `bind=`: Specifies binding relationships (see Binding section)
- `init=`: Dict or lambda for initialization values
- `default=`: Default value
- `default_factory=`: Factory for default values

#### Port/Signal Declarations
- **zdc.input()**: Declares an input port/signal
- **zdc.output()**: Declares an output port/signal
- **zdc.port()**: Declares a port (for TLM interfaces)
- **zdc.export()**: Declares an export (provides service)

#### Other Field Types
- **zdc.const()**: Post-initialization constant
- **zdc.extern()**: Instance of external module (e.g., existing Verilog RTL)
- **zdc.lock()**: Lock resource field
- **zdc.share()**: Share resource field

## Components

Components provide the structural aspect of a Zuspec model. They can contain fields, sub-components, and executable methods.

### Basic Component Example
```python
@zdc.dataclass
class Counter(zdc.Component):
    clock : zdc.Bit = zdc.input()
    reset : zdc.Bit = zdc.input()
    count : zdc.Bit[32] = zdc.output()
```

### Executable Methods

#### @zdc.sync(clock=..., reset=...)
Marks a synchronous evaluation region evaluated on the active edge of clock or reset.

**Important**: Assignments in sync methods are delayed/nonblocking. Only the last assignment to a variable takes effect per cycle.

Example:
```python
@zdc.sync(clock=lambda s:s.clock, reset=lambda s:s.reset)
def _inc(self):
    if self.reset:
        self.count = 0
    else:
        self.count += 1  # Only this increment takes effect
        self.count += 1  # This is ignored - count only increases by 1
```

#### @zdc.comb(latch=False)
Marks a combinational evaluation region evaluated whenever referenced variables change. Used exclusively for RTL descriptions.

#### @zdc.process
Marks an always-running async process. The method must be `async` and take no arguments. Creates an independent thread of control.

Example:
```python
@zdc.process
async def run(self):
    for i in range(20):
        await self.do_something(i)
```

## Binding

Binding connects ports, inputs, outputs, and dependencies between components.

### Using zdc.bind
The `zdc.bind[T]` helper ensures type-safe binding specifications:

```python
@zdc.dataclass
class Top(zdc.Component):
    clock : zdc.Bit = zdc.input()
    reset : zdc.Bit = zdc.input()
    
    counter : Counter = zdc.field(bind=zdc.bind[Self](lambda s: {
        s.counter.clock : s.clock,
        s.counter.reset : s.reset
    }))
    
    monitor : Monitor = zdc.field(bind=zdc.bind[Self](lambda s: {
        s.monitor.clock : s.clock,
        s.monitor.reset : s.reset,
        s.monitor.count : s.counter.count
    }))
```

The lambda receives the parent component (`s`) and returns a dictionary mapping target fields to source fields.

## Actions

Actions are dynamic behavioral elements frequently used for modeling test behavior. They are typically associated with a component type.

```python
@zdc.dataclass
class MyC(zdc.Component):
    a : int = 5

@zdc.dataclass
class MyA(zdc.Action[MyC]):
    async def activity(self):
        # Access component through self.comp
        print("comp.a=%d" % self.comp.a)
```

### Action Methods
- **activity()**: Async method providing action implementation with activity semantics
- **body()**: Async method providing action implementation
- **post_solve()**: Called after randomization

## Constraints

Constraints relate values of random variables using declarative specifications.

### Constraint Blocks
```python
@zdc.dataclass
class MyS(zdc.Struct):
    a : int = zdc.field(rand=True)
    b : int = zdc.field(rand=True)

    @zdc.constraint
    def ab_c(self):
        self.a > 0 and self.a < 10
        self.b in range(0,9)
        self.a < self.b
```

All statements in a constraint method are treated as boolean constraints that must hold concurrently.

### Constraint Operators
- Comparison: `<`, `>`, `<=`, `>=`, `==`, `!=`
- Logical: `and`, `or`, `not`
- **in** operator: `self.a in range(10)` constrains a to 0..9
- Supports `range()`, generators, lists, tuples

## TLM (Transaction Level Modeling)

Zuspec provides interfaces for transaction-level communication:

```python
@zdc.dataclass
class Producer(zdc.Component):
    dat_o : Callable[[int],Awaitable] = zdc.port()
    dat_i : Callable[[int],Awaitable] = zdc.export(bind=zdc.bind[Self](lambda s:s.recv))

    async def recv(self, dat):
        # Handle received data
        pass

    @zdc.process
    async def run(self):
        for i in range(20):
            await self.dat_o(i)
```

## Dependencies

Dependencies provide dependency-injection pattern for modeling. Components can specify required services, which are provided by the containing environment.

Example with Timebase dependency:
```python
@zdc.dataclass
class SubC1(zdc.Component):
    count : zdc.Bit[32] = zdc.output()

    @zdc.sync
    def _inc(self):
        self.count += 1

@zdc.dataclass
class Upper(zdc.Component):
    clock : zdc.Bit = zdc.input()
    reset : zdc.Bit = zdc.input()

    _timebase : zdc.TimebaseClockReset = zdc.field(
        init=dict(clock=lambda s:s.clock, reset=lambda s:s.reset))

    _c1_1 : SubC1 = zdc.field()  # Automatically inherits timebase
    _c1_2 : SubC1 = zdc.field()  # Automatically inherits timebase
```

## Key Semantic Rules

### Synchronous Methods (@zdc.sync)
1. Assignments are delayed/nonblocking - they only take effect after method completes
2. Multiple assignments to the same variable: only the last one takes effect
3. Augmented assignments (+=, -=, etc.) are treated as delayed assignments
4. Use for RTL modeling with clock-based updates

### Assignment Semantics Example
```python
@zdc.sync(clock=lambda s:s.clock, reset=lambda s:s.reset)
def _update(self):
    self.val1 = self.val1 + 1
    self.val1 = self.val1 + 1  # Only this takes effect
    self.val2 += 1
    self.val2 += 1  # Only this takes effect
# Result: both val1 and val2 increase by 1, not 2
```

### Type Elaboration
Components with `__post_init__` or const parameters are tracked as distinct types when parameter values differ.

## Common Patterns

### Simple Counter
```python
@zdc.dataclass
class Counter(zdc.Component):
    clock : zdc.Bit = zdc.input()
    reset : zdc.Bit = zdc.input()
    count : zdc.Bit[32] = zdc.output()

    @zdc.sync(clock=lambda s:s.clock, reset=lambda s:s.reset)
    def _inc(self):
        if self.reset:
            self.count = 0
        else:
            self.count += 1
```

### Hierarchical Component with Binding
```python
@zdc.dataclass
class Top(zdc.Component):
    clock : zdc.Bit = zdc.input()
    reset : zdc.Bit = zdc.input()
    
    sub1 : SubModule = zdc.field(bind=zdc.bind[Self](lambda s: {
        s.sub1.clock : s.clock,
        s.sub1.reset : s.reset
    }))
```

### Randomizable Struct
```python
@zdc.dataclass
class Transaction(zdc.Struct):
    addr : int = zdc.field(rand=True)
    data : int = zdc.field(rand=True)
    
    @zdc.constraint
    def addr_range_c(self):
        self.addr in range(0, 1024)
        self.data >= 0 and self.data < 256
```

## Processing Tools API

The `zuspec.dataclasses.api` package provides a visitor interface for tools to iterate over Zuspec model features. This allows backend tools to generate implementations (e.g., Verilog RTL, SystemC models, testbenches).

## Best Practices

1. Use `@zdc.dataclass` on all Zuspec class definitions
2. Use type hints for all fields
3. Use `lambda s:s.field` pattern for accessing parent component in bindings
4. Remember sync method assignments are delayed - only last assignment counts
5. Use `zdc.bind[Self]` for type-safe binding specifications
6. Mark randomizable fields with `rand=True`
7. Use constraints to specify relationships between random variables
8. Use dependencies for implicit service provision (like timebase, clock/reset)

## Profiles

Zuspec supports model profiles to specify capability sets and restrictions:
- Synthesizable RTL
- Behavioral RTL
- Behavioral HVL
- Portable TLM
- Python simulation

Tools enforce profile restrictions on tagged content.

## License

Copyright 2019-2025 Matthew Ballance and contributors
Licensed under Apache License 2.0
