# Zuspec Dataclasses - LLM Instructions

## Overview

Zuspec is a Python-embedded multi-abstraction language for modeling digital hardware designs at multiple levels of abstraction, from abstract behavioral models down to register transfer level (RTL). It follows the Python `dataclasses` pattern and applies special semantic rules to create hardware descriptions.

## Core Concepts

### 1. Import Convention
```python
import zuspec.dataclasses as zdc
```

### 2. Base Types

#### TypeBase
All Zuspec types derive from TypeBase.

#### Bit Type
- Unsigned integer type with configurable width
- Default width: 1 bit
- Usage: `zdc.Bit` or `zdc.Bit[W]` where W is the width
- Example: `count : zdc.Bit[32]` creates a 32-bit unsigned field
- Values are automatically masked to the specified width

#### Int Type
- Signed integer type with configurable width
- Default width: 32 bits
- Usage: `zdc.Int` or `zdc.Int[W]` where W is the width
- Example: `value : zdc.Int[64]` creates a 64-bit signed field

#### Struct
Data structures that may contain variable-size fields. Supports:
- Random fields (for randomization)
- Constraint methods
- Regular methods

#### StructPacked
Fixed-size data structures where all fields must be of fixed size.

#### Component
Structural elements equivalent to Verilog modules or SystemC components. Components:
- Can have input/output ports
- Support synchronous and combinational logic
- Can contain subcomponents
- Have a defined lifecycle (construction, init_down, init_up)

#### Action
Dynamic behavioral elements typically used for modeling test behavior. Actions are associated with a component type using generics: `class MyAction(zdc.Action[MyComponent])`.

### 3. Decorators

#### @zdc.dataclass
Marks a class as a Zuspec dataclass. Must be used on all Component, Struct, and Action types.

Example:
```python
@zdc.dataclass
class MyComponent(zdc.Component):
    ...
```

#### @zdc.sync(clock, reset)
Marks a method as synchronous - evaluated on the active edge of clock or reset.

**Critical Semantic Rule**: Assignments in sync methods are NONBLOCKING/DELAYED:
- Assignments only take effect AFTER the entire method completes
- Multiple assignments to the same variable in one evaluation: only the LAST assignment takes effect
- Augmented assignments (+=, -=, etc.) are treated the same as regular assignments
- Reading a variable returns its value at the START of the method evaluation

Example:
```python
@zdc.sync(clock=lambda s:s.clock, reset=lambda s:s.reset)
def _inc(self):
    if self.reset:
        self.count = 0
    else:
        self.count += 1  # First increment
        self.count += 1  # Only this final value takes effect
# Result: count increments by 1, not 2
```

#### @zdc.comb(latch=False)
Marks a combinational evaluation region evaluated whenever input variables change. Used for RTL descriptions.

#### @zdc.process
Marks an always-running async process. The method must be `async` and takes no arguments.

#### @zdc.constraint
Marks a constraint method. All statements are treated as concurrent boolean constraints (not procedural).

### 4. Field Types

#### input()
Marks an input port on a component. Inputs see the bound output value with no delay.

Example:
```python
clock : zdc.Bit = zdc.input()
```

#### output()
Marks an output port on a component.

Example:
```python
count : zdc.Bit[32] = zdc.output()
```

#### field(...)
Generic field declaration with options:
- `rand=True`: Makes the field randomizable
- `bind=...`: Specifies binding for subcomponents
- `init=dict(...)`: Initialization parameters
- `default=...`: Default value
- `default_factory=...`: Factory for default value

#### const(default=None)
Marks a field as a post-initialization constant.

#### port()
Marks a dependency port that must be bound.

#### export(...)
Marks a service provider field.

### 5. Binding

Use `zdc.bind[T](lambda s: {...})` to specify port bindings for subcomponents:

Example:
```python
@zdc.dataclass
class Top(zdc.Component):
    clock : zdc.Bit = zdc.input()
    counter : Counter = zdc.field(bind=zdc.bind[Self](lambda s: {
        s.counter.clock : s.clock,
        s.counter.reset : s.reset
    }))
```

The bind lambda returns a dictionary mapping subcomponent ports to parent signals.

### 6. Constraints

Constraint methods are declarative - all statements are concurrent boolean expressions:

```python
@zdc.constraint
def my_constraint(self):
    self.a > 0 and self.a < 10
    self.b in range(0, 9)
    self.a < self.b
```

Supported constructs:
- Boolean expressions
- `in` operator with ranges, lists, tuples
- if/else conditionals
- for loops
- match statements

### 7. Dependencies

Zuspec implements dependency injection for services like clocks, resets, and custom services. Components can:
- Require services (dependencies)
- Provide services to subcomponents
- Automatically resolve service bindings in the component hierarchy

### 8. Type Elaboration

Types are elaborated based on:
- Base type
- Const parameter values
- Post-init configuration

Two instances of the same base class with different const parameters are distinct types.

## Common Patterns

### Counter Example
```python
@zdc.dataclass
class Counter(zdc.Component):
    clock : zdc.Bit = zdc.input()
    reset : zdc.Bit = zdc.input()
    count : zdc.Bit[32] = zdc.output()

    @zdc.sync(clock=lambda s:s.clock, reset=lambda s:s.reset)
    def _inc(self):
        if self.reset:
            self.count = 0
        else:
            self.count += 1
```

### Hierarchical Design with Binding
```python
@zdc.dataclass
class SubModule(zdc.Component):
    clk : zdc.Bit = zdc.input()
    data : zdc.Bit[8] = zdc.output()

@zdc.dataclass
class Top(zdc.Component):
    clock : zdc.Bit = zdc.input()
    sub : SubModule = zdc.field(bind=zdc.bind[Self](lambda s: {
        s.sub.clk : s.clock
    }))
```

### Action with Component Association
```python
@zdc.dataclass
class MyComponent(zdc.Component):
    value : int = 5

@zdc.dataclass
class MyAction(zdc.Action[MyComponent]):
    async def body(self):
        print("comp.value=%d" % self.comp.value)
```

## Analysis Guidelines for LLMs

When analyzing Zuspec code:

1. **Sync Method Semantics**: Always remember assignments are delayed until method completion. Only the last assignment to each variable takes effect.

2. **Signal Propagation**: In hierarchical designs, track signal connections through bind specifications.

3. **Clock Edge Timing**: Sync methods execute on clock edges. Track the sequence of clock cycles to determine output values.

4. **Reset Behavior**: Check if reset is synchronous or asynchronous and handle accordingly.

5. **Initial Values**: Outputs are typically 0/undefined until explicitly set.

6. **Component Hierarchy**: Build a mental model of the component tree and signal flow.

7. **Constraint Solving**: Treat all constraint statements as concurrent, not sequential.

## API for Tools

The `zuspec.dataclasses.api` package provides a visitor interface for processing tools to iterate over Zuspec model features and generate implementations (e.g., Verilog RTL, SystemC, test generation).

## Profiles

Models can be tagged with profiles that specify capability sets:
- Synthesizable RTL
- Behavioral RTL
- Behavioral HVL
- Portable TLM
- Python simulation
- Formal verification

Tools enforce profile restrictions and verify conformance.
