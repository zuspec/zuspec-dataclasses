# Zuspec Dataclasses

> Python-embedded multi-abstraction language for modeling digital hardware from transfer-function level to RTL

## Overview

Zuspec is a Python-based domain-specific language for modeling digital hardware designs at multiple levels of abstraction. It enables creating behavioral models that can be transformed into various implementations addressing different points on the performance/fidelity curve.

## Core Concepts

### Import Convention
```python
import zuspec.dataclasses as zdc
```

### Base Types

**Components** - Structural elements equivalent to Verilog modules, SystemC components, or PSS components. Components provide the hierarchical structure of hardware models.

**Actions** - Dynamic behavioral elements typically used for modeling test behavior. Actions are associated with components and describe test scenarios.

**Bundles** - Collections of related ports, exports, inputs, outputs, or other bundles that can be connected together.

**Structs** - Data structures that may contain variable-size fields with support for constraints and methods.

**StructPacked** - Fixed-size data structures where all fields must have a fixed size.

## Data Types

### Numeric Types

**Bit** - Unsigned bit vectors with configurable width (default: 1 bit)
- Example: `zdc.Bit`, `zdc.Bit[32]`
- Values are automatically masked to the specified width

**Int** - Signed integers with configurable width (default: 32 bits)
- Example: `zdc.Int`, `zdc.Int[64]`
- Values are automatically masked to the specified width

### Type Declaration Examples
```python
@zdc.dataclass
class MyComponent(zdc.Component):
    int_64b : zdc.Int = zdc.field(width=64)
    bit_48b : zdc.Bit = zdc.field(width=48)
    count : zdc.Bit[32] = zdc.output()
```

## Components

### Declaration
Components must be decorated with `@zdc.dataclass` and inherit from `zdc.Component`:

```python
@zdc.dataclass
class Counter(zdc.Component):
    clock : zdc.Bit = zdc.input()
    reset : zdc.Bit = zdc.input()
    count : zdc.Bit[32] = zdc.output()
```

### Ports and I/O

**Port Types:**
- `zdc.input()` - Input port (consumer)
- `zdc.output()` - Output port (producer)
- `zdc.port()` - Generic port
- `zdc.export()` - Export (provider)
- `zdc.mirror()` - Mirror of a bundle

**Port Binding:**
Ports can be bound in two ways:

1. Inline binding using the `bind` parameter:
```python
@zdc.dataclass
class Top(zdc.Component):
    initiator : Initiator = zdc.field(bind=zdc.bind[Self,Initiator](lambda s,f:{
        f.clock : s.clock,
        f.reset : s.reset,
    }))
```

2. Using the `__bind__` method:
```python
@zdc.dataclass
class Top(zdc.Component):
    initiator : Initiator = zdc.field()
    
    def __bind__(self):
        return {
            self.initiator.clock : self.clock,
            self.initiator.reset : self.reset,
        }
```

### Execution Methods

Components support several decorated execution methods that are automatically evaluated based on events:

**@zdc.sync** - Synchronous execution on clock/reset edges (RTL)
```python
@zdc.sync(clock=lambda s:s.clock, reset=lambda s:s.reset)
def inc(self):
    if self.reset:
        self.count = 0
    else:
        self.count += 1
```
- All assignments to outputs are non-blocking
- Evaluated on active transition of associated clock or reset

**@zdc.comb** - Combinational logic (RTL)
- Evaluated whenever referenced variables change
- Used exclusively for RTL descriptions

**@zdc.process** - Independent thread of control
- Async method evaluated when component begins
- Creates independent execution thread

**@zdc.activity** - Activity method with special semantics
- Async method following activity semantics
- Can be declared on components and actions

### FSM (Finite State Machine) Support

```python
@zdc.dataclass
class MyFSM(zdc.Component):
    clock : zdc.Bit = zdc.input()
    reset : zdc.Bit = zdc.input()
    adv : zdc.Bit = zdc.input()

    _ctrl : zdc.FSM = zdc.fsm(
        clock=lambda s:s.clock,
        reset=lambda s:s.reset,
        initial=lambda s:s.init
    )

    @zdc.fsm.state
    def init(self):
        if self.adv:
            self._ctrl.state = self.s1

    @zdc.fsm.state
    def s1(self):
        if self.adv:
            self._ctrl.state = self.s2
```

## Actions

Actions model dynamic behavior and are typically used for test scenarios. They are associated with a component type:

```python
@zdc.dataclass
class MyC(zdc.Component):
    a : int = 5

@zdc.dataclass
class MyA(zdc.Action[MyC]):
    def post_solve(self):
        print("comp.a=%d" % self.comp.a)
```

### Action Methods

**activity** - Async method providing action implementation with activity semantics
**body** - Async method providing action implementation
**post_solve** - Called after constraint solving
**pre_solve** - Called before constraint solving

## TLM (Transaction-Level Modeling)

Zuspec supports transaction-level modeling for abstract communication:

```python
@zdc.dataclass
class Producer(zdc.Component):
    dat_o : Callable[[int],Awaitable] = zdc.port()
    dat_i : Callable[[int],Awaitable] = zdc.export(bind=zdc.bind[Self,Callable](lambda s:s.recv))
    
    async def recv(self, dat):
        # Handle received data
        pass

    @zdc.process
    async def run(self):
        for i in range(20):
            await self.dat_o(i)
```

## Field Declaration

Use `zdc.field()` to declare component fields with various options:

```python
@zdc.dataclass
class MyComponent(zdc.Component):
    # Basic field
    data : zdc.Bit[8] = zdc.field()
    
    # Field with width
    wide_data : zdc.Bit = zdc.field(width=64)
    
    # Field with initialization
    sub_comp : SubComponent = zdc.field(init=dict(param1=10, param2=20))
    
    # Const parameter
    param : int = zdc.const()
    
    # Field with default factory
    event : zdc.Event = zdc.field(default_factory=zdc.Event)
```

## Component Instantiation

Components are never instantiated directly. For testing, use a factory:

```python
import zuspec.dataclasses as zdc
import zuspec.be.py as zpy

@zdc.dataclass
class Top(zdc.Component):
    clock : zdc.Bit = zdc.input()
    reset : zdc.Bit = zdc.input()

top_i = zpy.Factory().build(Top)
```

## Timing and Synchronization

Components have async methods for timing control:

```python
async def wait(self, amt : float, units : int = 0):
    """Suspend execution for specified time using default timebase"""
```

## API and Tool Integration

The `zuspec.dataclasses.api` package provides a visitor pattern for tools to iterate over Zuspec model features. This enables code generation, analysis, and transformation tools to work with Zuspec descriptions.

## Type Elaboration

Zuspec performs type elaboration to track distinct types based on constant parameter values:

```python
@zdc.dataclass
class C1(zdc.Component):
    p1 : int = zdc.const()
    p2 : int = zdc.const()

@zdc.dataclass
class T(zdc.Component):
    c1_1 : C1 = zdc.field(init=dict(p1=20, p2=30))
    c1_2 : C1 = zdc.field(init=dict(p1=10, p2=20))
```

In this example, `c1_1` and `c1_2` are tracked as distinct types due to different parameter values.

## Key Principles

1. **Multi-abstraction modeling** - Support for both behavioral and RTL descriptions
2. **Python-embedded** - Uses Python syntax with special semantic rules
3. **Structural hierarchy** - Components provide hierarchical organization
4. **Port-based connectivity** - Explicit binding of communication interfaces
5. **Event-driven execution** - Methods execute based on clocks, resets, or other events
6. **Type safety** - Strong typing with parameterized types

## Common Patterns

### Counter Example (RTL)
```python
@zdc.dataclass
class Counter(zdc.Component):
    clock : zdc.Bit = zdc.input()
    reset : zdc.Bit = zdc.input()
    count : zdc.Bit[32] = zdc.output()

    @zdc.sync(clock=lambda s:s.clock, reset=lambda s:s.reset)
    def _inc(self):
        if self.reset:
            self.count = 0
        else:
            self.count += 1
```

### Producer-Consumer (TLM)
```python
@zdc.dataclass
class Producer(zdc.Component):
    dat_o : Callable[[int],Awaitable] = zdc.port()
    
    @zdc.process
    async def run(self):
        for i in range(20):
            await self.dat_o(i)

@zdc.dataclass
class Consumer(zdc.Component):
    dat_i : Callable[[int],Awaitable] = zdc.export(bind=zdc.bind[Self,Callable](lambda s:s.recv))
    
    async def recv(self, dat):
        # Process received data
        pass
```

## Development Setup

This project uses IVPM (IP and Verification Package Manager) for dependency management:

```bash
# Install dependencies
uvx ivpm update
```

## Package Structure

- `src/zuspec/dataclasses/` - Core library implementation
  - `types.py` - Base type definitions (Component, Action, Struct, etc.)
  - `decorators.py` - Decorators for dataclass, field, sync, process, etc.
  - `tlm.py` - Transaction-level modeling support
  - `api/` - Visitor API for tool integration
  - `std/` - Standard library components (timebase, clock_reset)
- `tests/unit/` - Unit tests with usage examples
- `docs/` - Sphinx documentation

## License

Apache License, Version 2.0
Copyright 2019-2025 Matthew Ballance and contributors
