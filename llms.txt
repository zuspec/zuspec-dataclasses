# Zuspec Dataclasses - LLM Usage Guide

## Overview

Zuspec is a Python-embedded multi-abstraction language for modeling hardware designs from transfer-function level down to Register Transfer Level (RTL). It provides decorators and types to capture hardware model semantics at various abstraction levels.

## Installation

```bash
pip install zuspec-dataclasses
```

For development, use IVPM for dependency management:
```bash
uvx ivpm update
```

## Core Concepts

### 1. Components

Components are structural elements similar to Verilog modules, SystemC components, or PSS components. They define hardware structure and behavior.

```python
import zuspec.dataclasses as zdc

@zdc.dataclass
class Counter(zdc.Component):
    clock : zdc.Bit = zdc.input()
    reset : zdc.Bit = zdc.input()
    count : zdc.Bit[32] = zdc.output()
    
    @zdc.sync(clock=lambda s:s.clock, reset=lambda s:s.reset)
    def _inc(self):
        if self.reset:
            self.count = 0
        else:
            self.count += 1
```

**Key Points:**
- Use `@zdc.dataclass` decorator on Component classes
- Never create component instances directly; use factory classes
- Components have ports (input/output/port/mirror)
- Support exec methods: `@comb`, `@sync`, `@process`

### 2. Data Types

**Zuspec Integer Types:**
- `Bit`: Unsigned integer type (default width: 1 bit)
- `Int`: Signed integer type (default width: 32 bits)
- `Bits`: Variable-width bit type

Use subscript syntax for width specification:
```python
@zdc.dataclass
class MyComponent(zdc.Component):
    data : zdc.Bit[64] = zdc.field()  # 64-bit unsigned
    counter : zdc.Int[16] = zdc.field()  # 16-bit signed
```

**Python Types:**
Standard Python types (int, str, list, dict, set, tuple) are also supported.

### 3. Ports and Signals

Port types:
- `input()`: Consumer port
- `output()`: Producer port
- `port()`: Bidirectional port
- `mirror()`: Mirrored port
- `export()`: Export port

```python
@zdc.dataclass
class Module(zdc.Component):
    clk : zdc.Bit = zdc.input()
    data_out : zdc.Bit[32] = zdc.output()
```

### 4. Bundles

Bundles group related signals together (similar to SystemVerilog interfaces):

```python
@zdc.dataclass
class WishboneInitiator(zdc.Bundle):
    ADR_WIDTH : int = zdc.const(default=32)
    DAT_WIDTH : int = zdc.const(default=32)
    adr : zdc.Bits = zdc.output(init=dict(width=lambda s:s.ADR_WIDTH))
    dat_w : zdc.Bits = zdc.output(init=dict(width=lambda s:s.DAT_WIDTH))
    dat_r : zdc.Bits = zdc.input(init=dict(width=lambda s:s.DAT_WIDTH))
    cyc : zdc.Bit = zdc.output()
    stb : zdc.Bit = zdc.output()
    ack : zdc.Bit = zdc.input()
    we : zdc.Bit = zdc.output()
```

### 5. Binding

Ports are bound together during component elaboration. Two methods:

**Inline binding:**
```python
@zdc.dataclass
class Top(zdc.Component):
    clock : zdc.Bit = zdc.input()
    sub : SubComponent = zdc.field(bind=zdc.bind[Self,SubComponent](
        lambda s,f: {
            f.clock : s.clock,
        }
    ))
```

**Method binding:**
```python
@zdc.dataclass
class Top(zdc.Component):
    clock : zdc.Bit = zdc.input()
    sub : SubComponent = zdc.field()
    
    def __bind__(self):
        return {
            self.sub.clock : self.clock,
        }
```

### 6. Exec Methods

**@sync**: Synchronous execution on clock/reset edge
```python
@zdc.sync(clock=lambda s:s.clock, reset=lambda s:s.reset)
def process(self):
    if self.reset:
        self.state = 0
    else:
        self.state += 1
```

**@comb**: Combinational logic (evaluated on input change)
```python
@zdc.comb
def logic(self):
    self.output = self.input_a & self.input_b
```

**@process**: Independent thread of control (async)
```python
@zdc.process
async def main_process(self):
    while True:
        await self.event.wait()
        # Process logic
```

### 7. Actions

Actions are dynamic behavioral elements for test behavior:

```python
@zdc.dataclass
class MyComponent(zdc.Component):
    value : int = 5

@zdc.dataclass
class MyAction(zdc.Action[MyComponent]):
    def post_solve(self):
        print(f"Component value: {self.comp.value}")
```

Actions must be evaluated in a scope providing the required component services.

### 8. Structs

Two flavors:
- Fixed-size packed struct with bit fields
- Class-like struct with dynamic-sized data

```python
@zdc.dataclass
class MyStruct(zdc.Struct):
    field1 : int = zdc.field()
    field2 : zdc.Bit[16] = zdc.field()
```

### 9. Constraints

Constraints relate random variable values. Use `@zdc.constraint` decorator:

```python
@zdc.dataclass
class MyStruct(zdc.Struct):
    a : int = zdc.field(rand=True)
    b : int = zdc.field(rand=True)
    
    @zdc.constraint
    def ab_constraint(self):
        self.a > 0 and self.a < 10
        self.b in range(0, 9)
        self.a < self.b
```

**Constraint functions** (reusable constraints):
```python
@zdc.constraint
def max_constraint(rv, v1, v2):
    rv == v1 if v1 > v2 else v2

@zdc.dataclass
class MyStruct(zdc.Struct):
    a : int = zdc.field(rand=True)
    b : int = zdc.field(rand=True)
    c : int = zdc.field(rand=True)
    
    @zdc.constraint
    def use_max(self):
        max_constraint(self.c, self.a, self.b)
```

### 10. FSM (Finite State Machine)

Use `@zdc.fsm` decorator for state machine definitions:

```python
@zdc.dataclass
class StateMachine(zdc.Component):
    @zdc.fsm
    def state_machine(self):
        # FSM implementation
        pass
```

## Common Patterns

### Creating Component Instances

Never instantiate components directly. Use a factory:

```python
import zuspec.dataclasses as zdc
import zuspec.be.py as zpy

@zdc.dataclass
class Top(zdc.Component):
    clock : zdc.Bit = zdc.input()

# Create instance using factory
top_inst = zpy.Factory().build(Top)
```

### Parameterized Components

Use const fields for parameters:

```python
@zdc.dataclass
class ParamComponent(zdc.Component):
    WIDTH : int = zdc.const(default=32)
    data : zdc.Bit = zdc.output(init=dict(width=lambda s:s.WIDTH))
```

### Field Initialization

Use `init` parameter with lambda for dynamic initialization:

```python
@zdc.dataclass
class MyComponent(zdc.Component):
    WIDTH : int = zdc.const(default=32)
    data : zdc.Bits = zdc.field(init=dict(width=lambda s:s.WIDTH))
```

## API Access

The `zuspec.dataclasses.api` package provides visitor patterns for tools:

```python
from zuspec.dataclasses.api import visitor, type_processor
```

## Important Decorators and Functions

- `@zdc.dataclass`: Mark classes as Zuspec dataclasses
- `@zdc.sync()`: Synchronous execution block
- `@zdc.comb`: Combinational logic
- `@zdc.process`: Process/thread execution
- `@zdc.fsm`: Finite state machine
- `@zdc.constraint`: Constraint block
- `@zdc.activity`: Activity method
- `zdc.field()`: Define fields with metadata
- `zdc.const()`: Constant parameter
- `zdc.input()`: Input port
- `zdc.output()`: Output port
- `zdc.port()`: Bidirectional port
- `zdc.mirror()`: Mirror port
- `zdc.export()`: Export port
- `zdc.bind[]`: Binding specification
- `zdc.binder()`: Binder helper

## Base Classes

- `zdc.Component`: Hardware component base class
- `zdc.Bundle`: Interface/bundle base class
- `zdc.Struct`: Data structure base class
- `zdc.Action[T]`: Action base class (generic over component type)
- `zdc.TypeBase`: Base marker for all Zuspec types

## Type System

- `zdc.Bit`: Unsigned bit type
- `zdc.Bits`: Variable-width bits
- `zdc.Int`: Signed integer type

## Execution Models

**RTL (Register Transfer Level):**
- Use `@sync` for clocked processes
- Use `@comb` for combinational logic
- Assignments in `@sync` are non-blocking

**Behavioral:**
- Use `@process` for concurrent threads
- Use async/await for activity semantics
- Use `@activity` decorator for activity methods

## Testing

Tests use standard pytest framework:

```python
import pytest
import zuspec.dataclasses as zdc

def test_component():
    @zdc.dataclass
    class TestComp(zdc.Component):
        data : zdc.Bit[8] = zdc.field()
    
    # Test logic here
```

## Best Practices

1. Always use `@zdc.dataclass` decorator on Component, Bundle, Struct, and Action classes
2. Use type hints for all fields
3. Prefer lambda functions for dynamic field initialization
4. Use const fields for component parameters
5. Bind ports in `__bind__` method or inline with field declaration
6. Use appropriate exec methods based on abstraction level (@sync for RTL, @process for behavioral)
7. Keep constraint blocks declarative (no procedural logic)
8. Use factories to instantiate top-level components

## Common Errors to Avoid

- Don't create component instances with `ComponentClass()` directly
- Don't use procedural logic in constraint blocks
- Don't forget to specify clock/reset in `@sync` decorator
- Don't mix blocking and non-blocking semantics in RTL descriptions
- Remember that `@sync` assignments are non-blocking (last write wins)

## Resources

- Source: `/src/zuspec/dataclasses/`
- Documentation: `/docs/`
- Tests: `/tests/unit/`
- Project repository: https://github.com/zuspec/zuspec-dataclasses

## Version

Current version: 0.0.1

## License

Apache License 2.0
