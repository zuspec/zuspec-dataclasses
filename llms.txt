# Zuspec Dataclasses

> A Python-embedded multi-abstraction language for modeling hardware from transfer-function level to RTL

## Overview

Zuspec is a Python-based language that provides decorators and types to capture hardware model semantics across multiple abstraction levels. It allows developers to create hardware descriptions that can be transformed into various implementations, from abstract behavioral models down to register transfer level (RTL) designs.

## Key Concepts

### Language Philosophy
- **Python-embedded**: Uses Python syntax with special semantic rules applied to decorated portions
- **Multi-abstraction**: Supports modeling from high-level behavioral descriptions to synthesizable RTL
- **Profile-based**: Different profiles define capabilities and restrictions (Synthesizable RTL, Behavioral RTL, TLM, etc.)
- **Type-aware**: Leverages Python's type system with hardware-specific types

### Core Components

#### 1. Data Types

**Zuspec Integer Types:**
- `Bit`: Unsigned bit type, default width 1 bit
- `Int`: Signed integer type, default width 32 bits
- Width can be customized: `Bit[16]`, `Int[64]`
- Python types also supported: `int`, `str`, `list`, `dict`, `set`, `tuple`

**Example:**
```python
import zuspec.dataclasses as zdc

@zdc.dataclass
class MyC(zdc.Component):
    int_64b : zdc.Int = zdc.field(width=64)
    bit_48b : zdc.Bit = zdc.field(width=48)
```

#### 2. Struct Types

Two flavors of struct:
- **Packed struct**: Fixed-size with bit field support
- **Class-like struct**: Dynamic-sized data support

**Example:**
```python
@zdc.dataclass
class MyS(zdc.Struct):
    a : int = zdc.field(rand=True)
    b : int = zdc.field(rand=True)
```

#### 3. Components

Structural elements equivalent to Verilog modules, SystemC components, or PSS components.

**Key Features:**
- Define structural hierarchy
- Support input/output ports
- Contain exec methods (comb, sync, process)
- Support activities and processes

**Example:**
```python
@zdc.dataclass
class Counter(zdc.Component):
    clock : zdc.Bit = zdc.input()
    reset : zdc.Bit = zdc.input()
    count : zdc.Bit[32] = zdc.output()

    @zdc.sync(clock=lambda s:s.clock, reset=lambda s:s.reset)
    def _inc(self):
        if self.reset:
            self.count = 0
        else:
            self.count += 1
```

#### 4. Actions

Dynamic behavioral elements typically used for modeling test behavior. Actions are associated with components.

**Example:**
```python
class MyC(zdc.Component):
    a : int = 5

class MyA(zdc.Action[MyC]):
    def post_solve(self):
        print("comp.a=%d" % self.comp.a)
```

## Field Declarations

Fields follow Python's dataclasses pattern with hardware-specific semantics:

**Field Types:**
- `zdc.field()`: General purpose field with customizable properties
- `zdc.input()`: Input port declaration
- `zdc.output()`: Output port declaration
- `zdc.port()`: Port for dependency binding
- `zdc.export()`: Dependency provider
- `zdc.const()`: Constant parameter
- `zdc.rand()`: Random field convenience method

**Field Properties:**
- `rand`: Marks field as randomizable
- `const`: Marks field as constant
- `default`: Reset/default value
- `domain`: Iterable or callable defining field domain
- `bind`: Binding configuration
- `init`: Dictionary of initialization values
- `width`: Bit width for Bit/Int types

## Exec Methods

Methods that are evaluated automatically based on model events:

### @sync
Evaluated on clock or reset transitions (RTL descriptions).
- All assignments to outputs are nonblocking
- Used for synchronous logic

```python
@zdc.sync(clock=lambda s:s.clock, reset=lambda s:s.reset)
def inc(self):
    if self.reset:
        self.count = 0
    else:
        self.count += 1
```

### @comb
Evaluated whenever referenced variables change (RTL descriptions).
- Used for combinational logic

### @process
Async exec method evaluated when component evaluation begins.
- Independent thread of control

```python
@zdc.process
async def run(self):
    for i in range(20):
        await self.some_operation()
```

### @activity
Async methods for activity-based execution.
- Body adheres to activity semantics
- Can be defined on components or actions

## Constraints

Constraint methods relate values of random variables using declarative constraints.

**Constraint Blocks:**
```python
@zdc.dataclass
class MyS(zdc.Struct):
    a : int = zdc.field(rand=True)
    b : int = zdc.field(rand=True)

    @zdc.constraint
    def ab_c(self):
        self.a > 0 and self.a < 10
        self.b in range(0,9)
        self.a < self.b
```

**Constraint Functions:**
Reusable constraints activated by reference:
```python
@zdc.constraint
def max(rv, v1, v2):
    rv == v1 if v1 > v2 else v2

@zdc.constraint(fn=True)
def a_range_small(self):
    self.a in range(0,9)
```

**Constraint Operators:**
- Boolean expressions: `and`, `or`, `not`, `==`, `!=`, `<`, `>`, etc.
- `in` operator: For range and iterable constraints
- Control flow: `if/else`, `for`, `match`

## TLM (Transaction Level Modeling)

Support for transaction-level interfaces:

**TLM Interfaces:**
- `IPut[T]`: Put interface with `put` method
- `IGet[T]`: Get interface with `get` method
- `IReqRsp[ReqT, RspT]`: Request-response interface

**Example:**
```python
@zdc.dataclass
class Producer(zdc.Component):
    dat_o : Callable[[int],Awaitable] = zdc.port()
    dat_i : Callable[[int],Awaitable] = zdc.export(bind=zdc.bind[Self](lambda s:s.recv))
    
    async def recv(self, dat):
        # Handle received data
        pass
    
    @zdc.process
    async def run(self):
        for i in range(20):
            await self.dat_o(i)
```

## Dependency Binding

Components can define dependency relationships using bind specifications:

```python
@zdc.dataclass
class Top(zdc.Component):
    p : Producer = zdc.field(bind=zdc.bind[Self](lambda s: {
        s.p.dat_i : s.c.dat_o
    }))
    c : Consumer = zdc.field(bind=zdc.bind[Self](lambda s: {
        s.c.dat_i : s.p.dat_o
    }))
```

## API for Tool Integration

The `zuspec.dataclasses.api` package provides a visitor pattern for tool integration:

**Type Processor:**
Process and transform Zuspec types for code generation or analysis.

**Visitor:**
Iterate over key features of a Zuspec model to extract information or generate code.

**Example Usage:**
```python
import zuspec.dataclasses.api as api

# Use visitor to traverse and process model
visitor = api.Visitor()
# Process components, fields, constraints, etc.
```

## Common Usage Patterns

### 1. Simple Counter (RTL)
```python
import zuspec.dataclasses as zdc

@zdc.dataclass
class Counter(zdc.Component):
    clock : zdc.Bit = zdc.input()
    reset : zdc.Bit = zdc.input()
    count : zdc.Bit[16] = zdc.output()

    @zdc.sync(clock=lambda s:s.clock, reset=lambda s:s.reset)
    def _inc(self):
        if self.reset:
            self.count = 0
        else:
            self.count += 1
```

### 2. Randomizable Struct
```python
@zdc.dataclass
class MyS(zdc.Struct):
    W : int = zdc.const(default=10)
    a : int = zdc.field(rand=True, domain=range(10))
    b : int = zdc.rand()
    
    @zdc.constraint
    def _c(self):
        self.a < self.b
```

### 3. Producer-Consumer Pattern
```python
@zdc.dataclass
class Producer(zdc.Component):
    dat_o : Callable[[int],Awaitable] = zdc.port()
    
    @zdc.process
    async def run(self):
        for i in range(10):
            await self.dat_o(i)

@zdc.dataclass
class Consumer(zdc.Component):
    dat_i : Callable[[int],Awaitable] = zdc.export(bind=zdc.bind[Self](lambda s:s.recv))
    
    async def recv(self, dat):
        print(f"Received: {dat}")
```

### 4. Component with Timebase
```python
@zdc.dataclass
class MyC(zdc.Component):
    async def do_work(self):
        await self.wait(10, -9)  # Wait 10 time units
        await self.wait_next(5)  # Wait 5 cycles
```

## Profiles

Profiles specify capabilities and restrictions for different use cases:

- **Synthesizable RTL**: Strict RTL subset that can be synthesized
- **Behavioral RTL**: RTL with behavioral constructs
- **Behavioral HVL**: Hardware verification language features
- **Portable TLM**: Transaction-level modeling
- **Portable PV**: Programmer's view modeling
- **Portable Test**: Test scenario descriptions
- **Python**: Full Python semantics
- **Static/Formal**: For formal verification

## Best Practices

1. **Use appropriate abstraction level**: Choose the right profile for your modeling needs
2. **Leverage type annotations**: Proper typing helps with validation and code generation
3. **Follow dataclasses pattern**: Use `@zdc.dataclass` decorator and field declarations
4. **Separate concerns**: Use components for structure, actions for behavior
5. **Use constraints declaratively**: Write constraints as boolean relationships, not procedures
6. **Bind dependencies explicitly**: Clear binding makes component reuse easier
7. **Use exec methods appropriately**: Choose between `@sync`, `@comb`, and `@process` based on semantics

## Installation and Setup

Install using pip:
```bash
pip install zuspec-dataclasses
```

For development, use IVPM for dependency management:
```bash
uvx ivpm update
```

## Import Pattern

Standard import:
```python
import zuspec.dataclasses as zdc
```

With API access:
```python
import zuspec.dataclasses as zdc
import zuspec.dataclasses.api as api
```

## Additional Resources

- Components are similar to: Verilog modules, SystemC components, PSS components
- Constraints follow similar patterns to: SystemVerilog constraints, PSS constraints
- TLM interfaces align with: SystemC TLM concepts
- Actions are similar to: PSS actions, UVM sequences

## Type System Notes

- Type variants are expanded during elaboration
- Components with different constant parameter values are tracked as distinct types
- `__post_init__` methods trigger type elaboration to determine specific types
- The visitor API provides access to elaborated type information

## Common Decorators Summary

- `@zdc.dataclass`: Mark a class as a Zuspec type
- `@zdc.sync()`: Synchronous exec method (RTL)
- `@zdc.comb`: Combinational exec method (RTL)
- `@zdc.process`: Process exec method (behavioral)
- `@zdc.activity`: Activity method
- `@zdc.constraint`: Constraint block or function

## Common Field Functions Summary

- `zdc.field()`: General field with properties
- `zdc.input()`: Input port
- `zdc.output()`: Output port
- `zdc.port()`: Dependency port
- `zdc.export()`: Dependency provider
- `zdc.const()`: Constant parameter
- `zdc.rand()`: Random field
- `zdc.bind[]()`: Binding specification

## Error Handling

- Constraint violations are detected during randomization
- Scheduling rule violations detected at runtime
- Type mismatches caught during elaboration
- Binding errors reported during connection phase

---

This documentation provides the essential information for LLMs to understand and use the Zuspec Dataclasses library for hardware modeling tasks.
