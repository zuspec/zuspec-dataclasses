# Zuspec Dataclasses - LLM Instructions

## Overview

Zuspec is a Python-embedded multi-abstraction language for modeling digital hardware designs at multiple levels of abstraction - from abstract behavioral models down to register transfer level (RTL). It uses Python syntax but applies special semantic rules to decorated portions of the description.

## Package Information

- **Package Name**: zuspec-dataclasses
- **Version**: 0.0.1
- **Import Statement**: `import zuspec.dataclasses as zdc`

## Core Concepts

### 1. Components

Components provide the structural aspect of a Zuspec model, similar to SystemVerilog modules, SystemC components, or PSS components.

**Key Features:**
- Structural elements of hardware designs
- Support input/output ports
- Can contain synchronous, combinational, or process-based behavior
- Declared using `@zdc.dataclass` decorator on classes that inherit from `zdc.Component`

**Example:**
```python
import zuspec.dataclasses as zdc

@zdc.dataclass
class Counter(zdc.Component):
    clock : zdc.Bit = zdc.input()
    reset : zdc.Bit = zdc.input()
    count : zdc.Bit[32] = zdc.output()
    
    @zdc.sync(clock=lambda s:s.clock, reset=lambda s:s.reset)
    def _inc(self):
        if self.reset:
            self.count = 0
        else:
            self.count += 1
```

### 2. Data Types

**Zuspec Integer Types:**
- `Bit` - Unsigned integer type with default width of 1 bit
- `Int` - Signed integer type with default width of 32 bits
- Width customization: Use subscript notation `Bit[48]` or `Int[64]`

**Python Types:**
Zuspec also supports standard Python types: `int`, `str`, `list`, `dict`, `set`, `tuple`

**Type Width Specification:**
```python
@zdc.dataclass
class MyC(zdc.Component):
    int_64b : zdc.Int = zdc.field(width=64)
    bit_48b : zdc.Bit = zdc.field(width=48)
```

### 3. Fields

Zuspec follows Python's dataclasses model for declaring class fields. Field semantics are captured through field initializers.

**Field Types:**
- `zdc.field()` - Basic data field with optional parameters:
  - `rand=True` - Marks field as randomizable
  - `bind` - Specifies dependency bindings
  - `init` - Dictionary or callable for initialization values
  - `default` - Default value
  - `default_factory` - Factory function for default value

- `zdc.input()` - Input port (sees bound output value with no delay)
- `zdc.output()` - Output port (can be bound to by inputs)
- `zdc.const()` - Post-initialization constant
- `zdc.port()` - Port field
- `zdc.export()` - Export field (makes container a dependency provider)

**Example:**
```python
@zdc.dataclass
class MyS(zdc.Struct):
    W : int = zdc.const(default=10)
    a : int = zdc.field(rand=True)
    b : zdc.Bit[16] = zdc.output()
```

### 4. Struct Types

Two flavors of struct:
- Fixed-size packed struct with bit field support
- Class-like struct with dynamic-sized data support

Structs can have randomizable fields and constraint methods.

### 5. Actions

Actions are dynamic behavioral elements typically used for modeling test behavior. They are associated with components and can access component state.

**Key Features:**
- Generic over component type: `class MyA(zdc.Action[MyC])`
- Access component via `self.comp`
- Support `activity` and `body` async methods
- Must be evaluated in scope providing required component services

**Example:**
```python
import zuspec.dataclasses as zdc

class MyC(zdc.Component):
    a : int = 5

class MyA(zdc.Action[MyC]):
    def post_solve(self):
        print("comp.a=%d" % self.comp.a)
```

### 6. Execution Methods

**@zdc.sync** - Synchronous method:
- Evaluated on active clock or reset transition
- All assignments to outputs are non-blocking (delayed until clock edge)
- Exclusively for RTL descriptions
- Parameters: `clock` and `reset` lambdas

**@zdc.comb** - Combinational method:
- Evaluated whenever referenced variables change
- Exclusively for RTL descriptions

**@zdc.process** - Process method:
- Async method evaluated when component evaluation begins
- Independent thread of control in the model

**@activity** - Activity method:
- Async method with activity semantics
- Can be declared on components or actions

### 7. Constraints

Constraints relate values of random variables. All statements in constraint methods are treated as boolean expressions applied concurrently (not procedurally).

**Constraint Blocks:**
```python
@zdc.dataclass
class MyS(zdc.Struct):
    a : int = zdc.field(rand=True)
    b : int = zdc.field(rand=True)
    
    @zdc.constraint
    def ab_c(self):
        self.a > 0 and self.a < 10
        self.b in range(0, 9)
        self.a < self.b
```

**Constraint Functions:**
- Reusable constraints with parameters
- Can be standalone or class methods
- Activated by referencing within constraint blocks
- Use `@zdc.constraint` or `@zdc.constraint(fn=True)` for class methods

**Supported Operators:**
- `in` operator with iterables (range, lists, tuples, generators)
- Boolean expressions
- if/else statements
- for loops with enumerate support
- match statements

### 8. Ports and Bindings

**Input/Output Semantics:**
- Inputs on top-level components are bound to implicit outputs
- Inputs on non-top-level components must explicitly be bound
- Inputs see output values with no delay

**Binding:**
- Use `bind` parameter in field declarations
- Can use lambda expressions for dynamic binding
- Use `zdc.bind` helper class for type-safe binding specifications

### 9. TLM (Transaction Level Modeling)

Interfaces for transaction-level communication:
- `IPut[T]` - Interface with `put` method for sending data
- `IGet[T]` - Interface with `get` method for receiving data
- `IReqRsp[ReqT, RspT]` - Request/response interface with both `put` and `get`

## API for Tool Integration

The `zuspec.dataclasses.api` package provides visitor patterns for tools to process Zuspec models:

**Key Modules:**
- `type_processor.py` - Process type definitions
- `visitor.py` - Iterate over model features

**Type Processing:**
- Types are elaborated during construction
- Type variants with different parameter values are tracked as distinct types
- `__post_init__` triggers type elaboration

## Semantic Rules

### Assignment Semantics

**In @sync methods:**
- All assignments to outputs are non-blocking (delayed)
- Only last assignment takes effect before clock edge
- Example: `self.count += 1; self.count += 1` results in single increment

**In combinational contexts:**
- Assignments are immediate

### Randomization

**Built-in Methods:**
- `pre_randomize()` - Called before randomization
- `post_randomize()` - Called after randomization
- `randomize()` - Perform randomization

## Profiles

Profiles specify sets of capabilities and restrictions that processing tools enforce:
- Synthesizable RTL
- Behavioral RTL
- Behavioral HVL (Hardware Verification Language)
- Portable TLM
- Portable Test
- Python execution

## Common Patterns

### 1. Simple Counter Component
```python
@zdc.dataclass
class Counter(zdc.Component):
    clock : zdc.Bit = zdc.input()
    reset : zdc.Bit = zdc.input()
    count : zdc.Bit[16] = zdc.output()
    
    @zdc.sync(clock=lambda s:s.clock, reset=lambda s:s.reset)
    def _inc(self):
        if self.reset:
            self.count = 0
        else:
            self.count += 1
```

### 2. Randomizable Struct
```python
@zdc.dataclass
class MyTransaction(zdc.Struct):
    addr : zdc.Bit[32] = zdc.field(rand=True)
    data : zdc.Bit[32] = zdc.field(rand=True)
    
    @zdc.constraint
    def addr_range(self):
        self.addr in range(0x1000, 0x2000)
```

### 3. Component with Action
```python
@zdc.dataclass
class MyComp(zdc.Component):
    status : int = 0

class MyAction(zdc.Action[MyComp]):
    async def activity(self):
        print(f"Component status: {self.comp.status}")
```

### 4. Parameterized Types
```python
@zdc.dataclass
class ParameterizedComp(zdc.Component):
    WIDTH : int = zdc.const()
    data : zdc.Bit = zdc.field()
    
    def __post_init__(self):
        # WIDTH is fixed at construction time
        # Each unique WIDTH value creates a distinct type
        pass
```

## Best Practices

1. **Use @zdc.dataclass decorator** on all Zuspec classes
2. **Type annotations are required** for all fields
3. **Inherit from appropriate base classes**: `Component`, `Struct`, `Action[T]`
4. **Use semantic field initializers** instead of plain values: `zdc.input()`, `zdc.output()`, etc.
5. **Constraint methods are declarative**, not procedural - all statements are concurrent boolean constraints
6. **Sync method assignments are non-blocking** - only final value before clock edge takes effect
7. **Actions are generic over component types** - use `Action[ComponentType]` pattern
8. **Width specification** - Use subscript for types: `Bit[32]` or field parameter: `field(width=32)`

## Dependencies and Resources

The library uses Python's dataclasses internally and extends them with hardware-specific semantics. Key dependencies are managed through IVPM (IP and Verification Package Manager).

## When Analyzing Zuspec Code

1. Identify the abstraction level (RTL, TLM, behavioral)
2. Recognize component structure and hierarchy
3. Understand signal/port connectivity through bindings
4. Evaluate synchronous behavior based on clock edges (non-blocking assignments)
5. Process constraints as concurrent boolean expressions
6. Track type parameterization and elaboration
7. Follow action-component associations for test behavior

## Error Handling

Common issues:
- Input ports on non-top components must have explicit bindings
- Constraint statements must be boolean expressions
- Sync methods require clock/reset parameters
- Type elaboration occurs during construction - const parameters must be set then
- Actions must be evaluated in scope providing required component services

## Additional Notes

- Zuspec aims to capture specification, not implementation
- Multiple implementations can be derived from a single Zuspec model
- The language supports multiple abstraction levels from transfer-function to RTL
- Type system tracks distinct types based on parameter values
- Association rules enable automatic dependency resolution
