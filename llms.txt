# Zuspec Dataclasses - LLM Usage Guide

Zuspec Dataclasses is a Python library for modeling digital hardware designs at multiple abstraction levels, from behavioral models to register transfer level (RTL). It uses Python dataclass syntax with special semantic rules for hardware modeling.

## Core Concepts

### Basic Structure
- All hardware models use `@zdc.dataclass` decorator
- Import the library as `import zuspec.dataclasses as zdc`
- Inherit from base types like `zdc.Component`, `zdc.Bundle`, `zdc.Struct`, etc.

### Main Types
- **Component**: Structural elements (equivalent to Verilog modules)
- **Bundle**: Collections of ports, exports, inputs, outputs
- **Struct**: Data structures with methods and constraints
- **Action**: Behavioral descriptions with component association

## Hardware Data Types

### Bit Types
```python
# Basic bit types
zdc.Bit        # Single bit (default)
zdc.Bit[32]    # 32-bit unsigned value
zdc.Bits       # Variable-width bits

# Signed integers
zdc.Int        # Signed integer
zdc.Int[16]    # 16-bit signed integer
```

### Field Decorators
```python
# Basic fields
field()              # Plain data field
const(default=val)   # Constant field
input()              # Input port
output()             # Output port
port()               # Generic port
export()             # Export field
mirror()             # Bundle mirror field
monitor()            # Bundle monitor field
```

## Component Structure

### Basic Component Template
```python
@zdc.dataclass
class MyComponent(zdc.Component):
    # Clock and reset (common pattern)
    clock : zdc.Bit = zdc.input()
    reset : zdc.Bit = zdc.input()
    
    # Data ports
    data_in : zdc.Bit[32] = zdc.input()
    data_out : zdc.Bit[32] = zdc.output()
    
    # Internal state
    _counter : zdc.Bit[8] = zdc.field()
    
    # Synchronous logic
    @zdc.sync(clock=lambda s:s.clock, reset=lambda s:s.reset)
    def _update(self):
        if self.reset:
            self._counter = 0
            self.data_out = 0
        else:
            self._counter += 1
            self.data_out = self.data_in
```

## Execution Models

### Synchronous Logic (`@zdc.sync`)
- Evaluated on clock/reset edges
- Uses non-blocking assignment semantics
- Multiple assignments to same variable: only last assignment takes effect
- Lambda functions specify clock/reset sources

```python
@zdc.sync(clock=lambda s:s.clock, reset=lambda s:s.reset)
def _sync_method(self):
    # Non-blocking assignments
    if self.reset:
        self.state = 0
    else:
        self.state += 1
```

### Combinational Logic (`@zdc.comb`)
- Evaluated when inputs change
- Immediate assignment semantics

```python
@zdc.comb()
def _comb_logic(self):
    self.output = self.input_a & self.input_b
```

### Process (`@zdc.process`)
- Always-running processes
- Must be async methods with no arguments

```python
@zdc.process
async def _background_task(self):
    while True:
        await self.wait(10)  # Wait 10 time units
        # Process logic
```

## Finite State Machines

```python
@zdc.dataclass
class StateMachine(zdc.Component):
    clock : zdc.Bit = zdc.input()
    reset : zdc.Bit = zdc.input()
    trigger : zdc.Bit = zdc.input()
    
    # FSM declaration
    _fsm : zdc.FSM = zdc.fsm(
        clock=lambda s:s.clock,
        reset=lambda s:s.reset,
        initial=lambda s:s.idle_state
    )
    
    @zdc.fsm.state
    def idle_state(self):
        if self.trigger:
            self._fsm.state = self.active_state
    
    @zdc.fsm.state
    def active_state(self):
        if not self.trigger:
            self._fsm.state = self.idle_state
```

## Bundles and Interfaces

### Bundle Definition
```python
@zdc.dataclass
class SimpleBus(zdc.Bundle):
    WIDTH : int = zdc.const(default=32)
    
    addr : zdc.Bits = zdc.output(init=dict(width=lambda s:s.WIDTH))
    data : zdc.Bits = zdc.output(init=dict(width=lambda s:s.WIDTH))
    valid : zdc.Bit = zdc.output()
    ready : zdc.Bit = zdc.input()
    
    @staticmethod
    def idle(bus : SimpleBus):
        bus.addr = 0
        bus.data = 0
        bus.valid = 0
```

### Using Bundles
```python
@zdc.dataclass
class BusController(zdc.Component):
    clock : zdc.Bit = zdc.input()
    reset : zdc.Bit = zdc.input()
    
    # Bundle instance
    bus_master : SimpleBus = zdc.field()
    
    # Bundle mirror (for connecting)
    bus_slave : SimpleBus = zdc.mirror()
```

## Binding and Connections

### Field Binding
```python
@zdc.dataclass
class Top(zdc.Component):
    clock : zdc.Bit = zdc.input()
    reset : zdc.Bit = zdc.input()
    
    # Bind sub-component ports
    cpu : CPU = zdc.field(bind=zdc.bind[Self,CPU](lambda s,f:{
        f.clock : s.clock,
        f.reset : s.reset,
        f.bus : s.memory.bus_port
    }))
    
    memory : Memory = zdc.field()
    
    # Alternative: __bind__ method
    def __bind__(self) -> Optional[Dict]:
        return {
            self.cpu.clock : self.clock,
            self.cpu.reset : self.reset,
            self.cpu.bus : self.memory.bus_port
        }
```

## Transaction Level Modeling (TLM)

### TLM Interfaces
```python
# Put interface
@zdc.dataclass
class Producer(zdc.Component):
    put_port : zdc.IPut[DataType] = zdc.port()
    
    async def send_data(self, data):
        await self.put_port.put(data)

# Get interface  
@zdc.dataclass
class Consumer(zdc.Component):
    get_port : zdc.IGet[DataType] = zdc.port()
    
    async def receive_data(self):
        data = await self.get_port.get()
        return data

# Request-Response interface
@zdc.dataclass
class Requester(zdc.Component):
    req_rsp : zdc.IReqRsp[ReqType, RspType] = zdc.port()
    
    async def transaction(self, req):
        await self.req_rsp.put(req)
        rsp = await self.req_rsp.get()
        return rsp
```

## Best Practices

### Naming Conventions
- Use `_` prefix for internal/private fields
- Clock/reset signals: `clock`, `reset`
- Active-low signals: `reset_n`, `enable_n`
- Bus interfaces: descriptive names like `axi_master`, `wb_slave`

### Common Patterns
1. **Clock Domain**: Always specify clock and reset for synchronous logic
2. **Reset Logic**: Handle reset state explicitly in sync blocks
3. **State Machines**: Use FSM decorator for complex state logic
4. **Parameterization**: Use const fields for compile-time parameters
5. **Hierarchy**: Use proper binding for component connections

### Field Initialization
- Use `init` parameter for dynamic width calculation
- Use `default` for static default values
- Use `default_factory` for object defaults

### Error Handling
- Zuspec types cannot be directly constructed (need type processor)
- Always use proper decorators for methods
- Ensure proper binding of hierarchical connections

## External Modules

### Extern Components
```python
@zdc.dataclass  
class ExternalRAM(zdc.ComponentExtern):
    # Interface definition
    addr : zdc.Bit[32] = zdc.input()
    data : zdc.Bit[32] = zdc.output()
    
    # External module specification
    _impl = zdc.extern(
        typename="ram_module",
        bind=lambda s: {"addr": s.addr, "data": s.data},
        files=["ram.v"],
        params={"DEPTH": 1024}
    )
```

This guide covers the essential patterns for using Zuspec Dataclasses effectively. The library enables hardware modeling with Python syntax while maintaining hardware semantics for synthesis and simulation tools.