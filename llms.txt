# Zuspec Dataclasses

Zuspec is a Python-embedded multi-abstraction language for modeling digital hardware designs from the transfer-function level down to register transfer level (RTL). It follows Python dataclasses patterns and applies special semantic rules to capture hardware model semantics.

## Installation

```bash
pip install zuspec-dataclasses
```

## Basic Usage

Import the library:
```python
import zuspec.dataclasses as zdc
```

## Core Concepts

### Components

Components are structural elements, equivalent to Verilog modules or SystemC components. They provide the structural aspect of a Zuspec model.

```python
@zdc.dataclass
class Counter(zdc.Component):
    clock : zdc.Bit = zdc.input()
    reset : zdc.Bit = zdc.input()
    count : zdc.Bit[32] = zdc.output()

    @zdc.sync(clock=lambda s:s.clock, reset=lambda s:s.reset)
    def _inc(self):
        if self.reset:
            self.count = 0
        else:
            self.count += 1
```

### Data Types

#### Integer Types

Zuspec defines two numeric types:
- `Bit` - Unsigned, default width of 1
- `Int` - Signed, default width of 32

Width customization using subscript notation:
```python
@zdc.dataclass
class MyC(zdc.Component):
    int_64b : zdc.Int = zdc.field(width=64)
    bit_48b : zdc.Bit = zdc.field(width=48)
    count : zdc.Bit[16] = zdc.output()  # 16-bit output
```

#### Struct Types

Two flavors of struct:
- `Struct` - Class-like struct with dynamic-sized data support
- `StructPacked` - Fixed-size packed struct with bit field support

```python
@zdc.dataclass
class MyS(zdc.Struct):
    a : int = zdc.field(rand=True)
    b : int = zdc.field(rand=True)
```

#### Bundle Types

Bundle types collect one or more ports, exports, inputs, outputs, or other bundles.

```python
@zdc.dataclass
class MyBundle(zdc.Bundle):
    data : zdc.Bit[32] = zdc.output()
    valid : zdc.Bit = zdc.output()
```

### Actions

Actions are dynamic behavioral elements frequently used for modeling test behavior. Actions are associated with a component type.

```python
class MyC(zdc.Component):
    a : int = 5

class MyA(zdc.Action[MyC]):
    def post_solve(self):
        print("comp.a=%d" % self.comp.a)
```

### Field Declarations

Field declarations follow Python dataclasses pattern with Zuspec-specific semantics:

```python
@zdc.dataclass
class MyS(zdc.Struct):
    W : int = zdc.const(default=10)          # Constant configured during init
    a : int = zdc.field(rand=True)           # Random field
    b : int = zdc.field(rand=True, domain=range(10))  # Constrained random
    clock : zdc.Bit = zdc.input()            # Input port
    reset : zdc.Bit = zdc.input()            # Input port
    count : zdc.Bit[16] = zdc.output()       # Output port
```

Field options:
- `rand=True` - Marks field as randomizable
- `default` - Reset/default value
- `domain` - Iterable or callable that produces field domain
- `width` - Bit width for Bit/Int types
- `bind` - Binding specification for dependencies
- `init` - Dictionary of initialization values

### Decorators

#### Component Execution Methods

**@sync** - Synchronous method evaluated on clock/reset edge:
```python
@zdc.sync(clock=lambda s:s.clock, reset=lambda s:s.reset)
def inc(self):
    if self.reset:
        self.count = 0
    else:
        self.count += 1
```

**@process** - Independent thread of control, async method:
```python
@zdc.process
async def run(self):
    for i in range(20):
        await self.dat_o(i)
```

**@comb** - Evaluated whenever referenced variables change (RTL descriptions only):
```python
@zdc.comb
def compute(self):
    self.result = self.a + self.b
```

#### Constraint Methods

**@constraint** - Constraint block for randomizable types:
```python
@zdc.dataclass
class MyS(zdc.Struct):
    a : int = zdc.field(rand=True)
    b : int = zdc.field(rand=True)

    @zdc.constraint
    def ab_c(self):
        self.a > 0 and self.a < 10
        self.b in range(0,9)
        self.a < self.b
```

Constraint statements follow Python syntax but are interpreted as concurrent boolean statements. All must hold True.

### Port and Dependency Management

**Port types:**
- `input()` - Input port
- `output()` - Output port  
- `port()` - Port dependency
- `export()` - Exported dependency provider
- `bind()` - Binding specification

Example with TLM-style interfaces:
```python
@zdc.dataclass
class Producer(zdc.Component):
    dat_o : Callable[[int],Awaitable] = zdc.port()
    dat_i : Callable[[int],Awaitable] = zdc.export(bind=zdc.bind[Self](lambda s:s.recv))

    async def recv(self, dat):
        # Implementation
        pass

    @zdc.process
    async def run(self):
        for i in range(20):
            await self.dat_o(i)
```

### Binding Components

Use `bind` parameter with `field()` to connect component ports:
```python
@zdc.dataclass
class Top(zdc.Component):
    p : Producer = zdc.field(bind=zdc.bind[Self](lambda s: {
        s.p.dat_i : s.c.dat_o
    }))
    c : Consumer = zdc.field(bind=zdc.bind[Self](lambda s: {
        s.c.dat_i : s.p.dat_o
    }))
```

## Advanced Features

### Profiles

Profiles specify capabilities and restrictions for processing tools:
- Synthesizable RTL
- Behavioral RTL
- Behavioral HVL
- Portable TLM
- Python

### Type Processing API

The `zuspec.dataclasses.api` package provides a visitor for iterating over Zuspec model features:
```python
from zuspec.dataclasses.api import TypeProcessor, Visitor
```

### External Components

Use `ComponentExtern` to interface with existing descriptions (e.g., Verilog RTL):
```python
@zdc.dataclass
class MyExtern(zdc.ComponentExtern):
    # Interface to existing Verilog module
    pass
```

## Common Patterns

### Simple Counter
```python
@zdc.dataclass
class Counter(zdc.Component):
    clock : zdc.Bit = zdc.input()
    reset : zdc.Bit = zdc.input()
    count : zdc.Bit[32] = zdc.output()

    @zdc.sync(clock=lambda s:s.clock, reset=lambda s:s.reset)
    def _inc(self):
        if self.reset:
            self.count = 0
        else:
            self.count += 1
```

### Constrained Random Struct
```python
@zdc.dataclass
class Transaction(zdc.Struct):
    addr : int = zdc.field(rand=True)
    data : int = zdc.field(rand=True)
    
    @zdc.constraint
    def valid_addr(self):
        self.addr in range(0, 1024)
        self.data in range(0, 256)
```

### Producer-Consumer with TLM
```python
@zdc.dataclass
class Producer(zdc.Component):
    dat_o : Callable[[int],Awaitable] = zdc.port()
    
    @zdc.process
    async def run(self):
        for i in range(10):
            await self.dat_o(i)

@zdc.dataclass
class Consumer(zdc.Component):
    dat_i : Callable[[int],Awaitable] = zdc.export(bind=zdc.bind[Self](lambda s:s.recv))
    
    async def recv(self, dat):
        print(f"Received: {dat}")
```

## Key Design Principles

1. **Python-embedded**: Uses Python syntax with special semantic rules
2. **Multi-abstraction**: Models from transfer-function level to RTL
3. **Dataclasses pattern**: Follows Python dataclasses conventions
4. **Type-driven**: Uses type annotations and field initializers for semantics
5. **Constraint-based**: Supports declarative constraints for randomization
6. **Component-based**: Structural hierarchy using components
7. **Async-aware**: Native support for asynchronous execution

## Important Notes

- All assignments in `@sync` methods are non-blocking (like Verilog)
- Constraint statements are concurrent boolean expressions, not procedural
- Actions must be evaluated within a component scope that provides required services
- Type elaboration happens during component construction
- External components (`ComponentExtern`) interface with existing HDL code

## Resources

- Documentation: docs/ directory contains comprehensive Sphinx documentation
- Examples: tests/unit/ directory contains working examples
- API: zuspec.dataclasses.api provides type processing capabilities
