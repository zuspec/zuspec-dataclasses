<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Abstraction Levels &#8212; Zuspec Language  documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=5ecbeea2" />
    <link rel="stylesheet" type="text/css" href="_static/basic.css?v=b08954a9" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css?v=27fed22d" />
    <script src="_static/documentation_options.js?v=5929fcd5"></script>
    <script src="_static/doctools.js?v=fd6eb6e6"></script>
    <script src="_static/sphinx_highlight.js?v=6ffebe34"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Zuspec IR Checker" href="checker.html" />
    <link rel="prev" title="Runtime Implementation (Developer)" href="runtime.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="abstraction-levels">
<h1>Abstraction Levels<a class="headerlink" href="#abstraction-levels" title="Link to this heading">¶</a></h1>
<section id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Link to this heading">¶</a></h2>
<p>ZuSpec-dataclasses models organize device interfaces across three key abstraction areas,
each serving different modeling and verification needs.</p>
<img alt="_images/design_abstraction.png" src="_images/design_abstraction.png" />
<ol class="arabic simple">
<li><p><strong>Logical Interface</strong> - How software sees and interacts with the device</p>
<ul class="simple">
<li><p>Operation level: High-level operations (e.g., “start DMA transfer”)</p></li>
<li><p>MMIO level: Register-based control and status visibility</p></li>
</ul>
</li>
<li><p><strong>Physical Interface</strong> - How the rest of the design interacts with the device</p>
<ul class="simple">
<li><p>Operation level: High-level operations (e.g., “start DMA transfer”)</p></li>
<li><p>MMIO: Memory-mapped register transactions</p></li>
<li><p>TLM: Transaction-level modeling (bus protocols)</p></li>
<li><p>Protocol: Pin-level signaling and timing</p></li>
</ul>
</li>
<li><p><strong>Internal Implementation</strong> - How the device implements its core algorithm</p>
<ul class="simple">
<li><p>Algorithmic: Functional behavior with or without timing</p></li>
<li><p>Cycle-accurate: Detailed microarchitectural implementation</p></li>
<li><p>Register-Transfer Level (RTL): Synthesizable implementation</p></li>
</ul>
</li>
</ol>
<p>These definitions extend to the system level as well:</p>
<img alt="_images/system_abstraction.png" src="_images/system_abstraction.png" />
<p>A primary difference between device and system view is more diversity in the
abstraction levels employed. For example, an RTL level of abstraction might be
employed for a key device within the system, while the rest is implemented
at the algorithmic level. This enables the full system to be simulated more
quickly, while preserving accuracy within the target device.</p>
</section>
<section id="logical-interface">
<h2>Logical Interface<a class="headerlink" href="#logical-interface" title="Link to this heading">¶</a></h2>
<p>The logical interface captures how the environment (typically software) interacts
with a device. There are two key abstraction levels in play here:</p>
<section id="operation-level">
<h3>Operation Level<a class="headerlink" href="#operation-level" title="Link to this heading">¶</a></h3>
<p>The operation level focuses on key device operations exposed as async methods,
representing the driver-level view of the device.</p>
<p><strong>Key characteristics:</strong></p>
<ul class="simple">
<li><p>Implements device operations as async methods</p></li>
<li><p>Effectively driver-level abstraction</p></li>
<li><p>Hides register-level details behind operation semantics</p></li>
<li><p>For devices supporting independent concurrent operations, group related
operations into Protocol classes</p></li>
</ul>
<p><strong>Example: DMA operation interface</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@zdc</span><span class="o">.</span><span class="n">dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">DmaOperations</span><span class="p">(</span><span class="n">Protocol</span><span class="p">):</span>
    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">transfer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">dst</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Perform a complete DMA transfer&quot;&quot;&quot;</span>
        <span class="c1"># Implementation uses MMIO level internally</span>
        <span class="k">pass</span>
</pre></div>
</div>
</section>
<section id="mmio-level">
<h3>MMIO Level<a class="headerlink" href="#mmio-level" title="Link to this heading">¶</a></h3>
<p>The MMIO level focuses on memory-mapped registers and events, providing
register-based control and visibility into device state.</p>
<p><strong>Key characteristics:</strong></p>
<ul class="simple">
<li><p>Interface is the register file and associated events</p></li>
<li><p>Operation-level methods are typically implemented in terms of this interface</p></li>
<li><p>Captures interrupt protocols through event abstractions</p></li>
<li><p>Memory-based descriptors are implied but not explicitly modeled</p></li>
</ul>
<p><strong>Core components:</strong></p>
<ul class="simple">
<li><p><strong>Register files</strong> (<code class="docutils literal notranslate"><span class="pre">zdc.RegFile</span></code>): Collections of memory-mapped registers</p></li>
<li><p><strong>Events</strong> (<code class="docutils literal notranslate"><span class="pre">zdc.Event</span></code>): Logical events like interrupts, completions, errors</p></li>
<li><p><strong>Protocol</strong> (<code class="docutils literal notranslate"><span class="pre">Protocol</span></code>): Grouping of related registers and events</p></li>
</ul>
<p><strong>Example: DMA MMIO interface</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@zdc</span><span class="o">.</span><span class="n">dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">DmaRegs</span><span class="p">(</span><span class="n">zdc</span><span class="o">.</span><span class="n">RegFile</span><span class="p">):</span>
    <span class="n">src_addr</span><span class="p">:</span> <span class="n">zdc</span><span class="o">.</span><span class="n">Reg</span><span class="p">[</span><span class="n">zdc</span><span class="o">.</span><span class="n">u32</span><span class="p">]</span>      <span class="c1"># Source address register</span>
    <span class="n">dst_addr</span><span class="p">:</span> <span class="n">zdc</span><span class="o">.</span><span class="n">Reg</span><span class="p">[</span><span class="n">zdc</span><span class="o">.</span><span class="n">u32</span><span class="p">]</span>      <span class="c1"># Destination address register</span>
    <span class="n">length</span><span class="p">:</span> <span class="n">zdc</span><span class="o">.</span><span class="n">Reg</span><span class="p">[</span><span class="n">zdc</span><span class="o">.</span><span class="n">u32</span><span class="p">]</span>        <span class="c1"># Transfer length register</span>
    <span class="n">control</span><span class="p">:</span> <span class="n">zdc</span><span class="o">.</span><span class="n">Reg</span><span class="p">[</span><span class="n">zdc</span><span class="o">.</span><span class="n">u8</span><span class="p">]</span>        <span class="c1"># Control register (start, stop, etc.)</span>
    <span class="n">status</span><span class="p">:</span> <span class="n">zdc</span><span class="o">.</span><span class="n">Reg</span><span class="p">[</span><span class="n">zdc</span><span class="o">.</span><span class="n">u8</span><span class="p">]</span>         <span class="c1"># Status register (busy, error, done)</span>

<span class="nd">@zdc</span><span class="o">.</span><span class="n">dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">DmaMmio</span><span class="p">(</span><span class="n">Protocol</span><span class="p">):</span>
    <span class="n">regs</span><span class="p">:</span> <span class="n">DmaRegs</span>                   <span class="c1"># Register file</span>
    <span class="n">transfer_complete</span><span class="p">:</span> <span class="n">zdc</span><span class="o">.</span><span class="n">Event</span>    <span class="c1"># Interrupt event</span>
    <span class="n">transfer_error</span><span class="p">:</span> <span class="n">zdc</span><span class="o">.</span><span class="n">Event</span>       <span class="c1"># Error event</span>
</pre></div>
</div>
</section>
</section>
<section id="physical-interface">
<h2>Physical Interface<a class="headerlink" href="#physical-interface" title="Link to this heading">¶</a></h2>
<p>The physical interface describes how the rest of the design interacts with the device
at various levels of implementation detail.</p>
<section id="id1">
<h3>Operation Level<a class="headerlink" href="#id1" title="Link to this heading">¶</a></h3>
<p>Early in the design cycle, it is common make the device’s physical interface the same
as the logical interface. This is because the internals of the device are often
implemented in terms of operations.</p>
</section>
<section id="id2">
<h3>MMIO Level<a class="headerlink" href="#id2" title="Link to this heading">¶</a></h3>
<p>Device views intended for use by software often directly expose a MMIO physical
interface. This allows software emulation frameworks (e.g. QEMU) to directly
interact with the device.</p>
</section>
<section id="tlm-level">
<h3>TLM Level<a class="headerlink" href="#tlm-level" title="Link to this heading">¶</a></h3>
<p>Transaction-level modeling provides a higher-level abstraction of bus interactions,
focusing on the transfer of data rather than signal-level details.</p>
<p><strong>Key characteristics:</strong></p>
<ul class="simple">
<li><p>Abstract transaction passing instead of cycle-by-cycle bus activity</p></li>
<li><p>Faster simulation performance</p></li>
<li><p>Suitable for system-level verification and performance analysis</p></li>
<li><p>Common for virtual prototyping and software development</p></li>
</ul>
</section>
<section id="protocol-level">
<h3>Protocol Level<a class="headerlink" href="#protocol-level" title="Link to this heading">¶</a></h3>
<p>Protocol-level modeling captures pin-accurate signaling and timing relationships
between the device and other hardware components.</p>
<p><strong>Key characteristics:</strong></p>
<ul class="simple">
<li><p>Models actual hardware signals and their timing</p></li>
<li><p>Captures protocol-specific handshaking (e.g., AXI, AHB, APB)</p></li>
<li><p>Used for detailed hardware verification</p></li>
<li><p>Includes clock-accurate behavior</p></li>
</ul>
</section>
</section>
<section id="internal-implementation">
<h2>Internal Implementation<a class="headerlink" href="#internal-implementation" title="Link to this heading">¶</a></h2>
<p>The internal implementation models describe how the device realizes its functionality,
from algorithmic behavior to cycle-accurate microarchitecture.</p>
<section id="algorithmic-level">
<h3>Algorithmic Level<a class="headerlink" href="#algorithmic-level" title="Link to this heading">¶</a></h3>
<p>Algorithmic modeling captures the functional behavior of the device with timing
characteristics but without detailed cycle-by-cycle implementation.</p>
<p><strong>Key characteristics:</strong></p>
<ul class="simple">
<li><p>Functional correctness with approximate timing</p></li>
<li><p>Models what the device does, not how it’s implemented</p></li>
<li><p>Suitable for performance modeling and early software development</p></li>
<li><p>Can be refined to more detailed implementations</p></li>
</ul>
<p><strong>Example use cases:</strong></p>
<ul class="simple">
<li><p>Golden reference models for verification</p></li>
<li><p>Performance estimation</p></li>
<li><p>Algorithm validation</p></li>
<li><p>Early software/firmware development</p></li>
</ul>
</section>
<section id="cycle-accurate-level">
<h3>Cycle-Accurate Level<a class="headerlink" href="#cycle-accurate-level" title="Link to this heading">¶</a></h3>
<p>Cycle-accurate modeling provides detailed microarchitectural implementation,
capturing behavior at individual clock cycle boundaries.</p>
<p><strong>Key characteristics:</strong></p>
<ul class="simple">
<li><p>Clock-cycle accurate state transitions</p></li>
<li><p>Models pipeline stages, arbitration, and resource conflicts</p></li>
<li><p>Captures detailed timing and performance characteristics</p></li>
<li><p>Used for RTL correlation and detailed performance analysis</p></li>
</ul>
<p><strong>Design considerations:</strong></p>
<ul class="simple">
<li><p>Operation granularity: How frequently is the block evaluated?</p>
<ul>
<li><p>At operational boundaries (coarse-grained)</p></li>
<li><p>At implementation boundaries (fine-grained)</p></li>
<li><p>Multiple levels of detail may coexist</p></li>
</ul>
</li>
<li><p>Timing assumptions: What timing guarantees are provided?</p>
<ul>
<li><p>Cycle boundaries</p></li>
<li><p>Pipeline depth</p></li>
<li><p>Resource availability</p></li>
</ul>
</li>
</ul>
</section>
<section id="register-transfer-level-rtl">
<h3>Register-Transfer Level (RTL)<a class="headerlink" href="#register-transfer-level-rtl" title="Link to this heading">¶</a></h3>
<p>RTL modeling provides a synthesizable description of design behavior that
can be taken directly to synthesis.</p>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">Zuspec Language</a></h1>









<search id="searchbox" style="display: none" role="search">
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" placeholder="Search"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">User Guide:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="intro.html">Zuspec Language Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="components.html">Components</a></li>
<li class="toctree-l1"><a class="reference internal" href="fields.html">Class Fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="types.html">Core Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="runtime.html">Runtime Implementation (Developer)</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Abstraction Levels</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#overview">Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="#logical-interface">Logical Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="#physical-interface">Physical Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="#internal-implementation">Internal Implementation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="checker.html">Zuspec IR Checker</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Advanced Topics:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="datamodel.html">Data Model (Developer)</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="runtime.html" title="previous chapter">Runtime Implementation (Developer)</a></li>
      <li>Next: <a href="checker.html" title="next chapter">Zuspec IR Checker</a></li>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2025, Matthew Ballance.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 9.1.0</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
      |
      <a href="_sources/abstraction_levels.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>